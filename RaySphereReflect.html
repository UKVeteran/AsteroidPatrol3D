<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>RaySphereReflect Demo</title>
	<style>
		body {
			background-color: rgb(0, 0, 0);
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="container"></div>

	<div id="help" style="position:fixed; left:35%; top:3%; color:grey;">
		Ray.intersectSphere(sphere)/reflect DEMO: Press 'M', then LMButton to Shoot, SPACE to thrust
	</div>
	
	<div id="help1" style="position:fixed; right:1%; bottom:8%; font-family:arial; font-size:10px; color:grey;">
		Desktop: Press 'M': MouseLook / LMouseButton: Fire / 'SPACE': Thrusters
	</div>

	<div id="help2" style="position:fixed; right:1%; bottom:4%; font-family:arial; font-size:10px; color:grey;">
		Mobile: Swipe to rotate / OrangeButton: Fire / PurpleButton: Thrusters
	</div>

	<div id="debug1" style="position:fixed; left:5%; top:3%; color:grey;">
		Debug Info
	</div>

	<div id="debug2" style="position:fixed; left:5%; top:6%; color:grey;">
		Debug Info
	</div>

	<div id="debug3" style="position:fixed; left:5%; top:9%; color:grey;">
		Debug Info
	</div>

	<div id="debug4" style="position:fixed; left:5%; top:12%; color:grey;">
		Debug Info
	</div>

	<script src="js/three.min.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script src="js/virtualButtonJoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/RaySphereReflectVariables.js"></script>

	<script>
		setup();
		animate();


		function setup() {

			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById("container").appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize, false);
			
			//collisionSphere is a copy of the dome mesh's (or any mesh's) boundingSphere.
			//this will essentially copy the size (radius) of the original boundingSphere
			collisionSphere1.copy(dome.geometry.boundingSphere);
			//now move collisionSphere's center to dome mesh's world location,
			//so it can be used for collision detection.
			//Note: if the dome mesh moves at all, the following line will need to 
			//accompany it every animation frame, to keep the collisionSphere properly updated
			collisionSphere1.center.copy(dome.position);
			
			//do the same for the white sphere mesh
			collisionSphere2.copy(whiteSphere.geometry.boundingSphere);
			collisionSphere2.center.copy(whiteSphere.position);
			
			//put the ship position at the origin
			ship.position.set(0, 0, 0);
			//put the camera right where the ship is
			camera.position.copy(ship.position);

		} //end function setup()

		function animate() {
			//keep looping through animate()
			requestAnimationFrame(animate);
			//store how much time has passed since the last animation frame
			frameTime = clock.getDelta();

			if (keyboard.pressed("M")) {

				mouseControl = true;

				if (canPressM) {
					//joystick.oldLon = controls.lon;
					//joystick.oldLat = controls.lat;
					joystick.savedMousePosX = joystick.mousePosX;
					joystick.savedMousePosY = joystick.mousePosY;
					//joystick._onDown(joystick.mousePosX, joystick.mousePosY);
					joystick.mouseDeltaX = 0;
					joystick.mouseDeltaY = 0;
					canPressM = false;
				}

			} else canPressM = true;

			if (mouseControl)
				joystick._pressed = true;

			//check if joystick Stick is being moved
			if (joystick._pressed) {

				if (mouseControl) {
					controls.lon = joystick.oldLon - (joystick.mouseDeltaX / 2);
					controls.lat = joystick.oldLat + (joystick.mouseDeltaY / 3);
				} else {
					//joystick left and right will turn the camera in that direction
					controls.lon = joystick.oldLon + (joystick.deltaX() / 3); // - 90
					//joystick up and down will tilt the camera up and down
					controls.lat = joystick.oldLat - (joystick.deltaY() / 4); // 0 -
				}

			}
			//if firebutton is NOT pressed, reset it so we can fire again
			if (!joystick.button1Pressed) {
				canShoot = true;
			}
			//if firebutton IS pressed, check to see if we can shoot
			if (joystick.button1Pressed) {
				if (canShoot) {
					shootBullet();
					//turn off shooting so we don't rapid fire
					canShoot = false;
				}
			}
			//if thrust button is pressed, apply thrust force to ship in the same direction that the camera is facing
			if (joystick.button2Pressed || keyboard.pressed('space')) {
				//reset the thrustVector to unit length of 1 to avoid accumulation
				thrustVector.set(0, 0, -1);
				//rotate thrustVector by our camera's rotation quaternion
				thrustVector.applyQuaternion(camera.quaternion);
				//now thrustVector has the right direction, but it needs magnitude also...
				//10 is the 'power' of the thruster; this is multiplied by framerate so it will run consistently on different systems
				thrustVector.multiplyScalar(10 * frameTime);
				//add this new thrust to the ship's ongoing velocity
				shipVelocity.add(thrustVector);
				//record the current speed of the ship, which equals the length of its velocity vector
				shipSpeed = shipVelocity.length();
				//now record just the direction and save it as a unit length vector (length of 1)
				normalizedShipDirection.copy(shipVelocity);
				//the following clamps this vector to a unit length of 1
				normalizedShipDirection.normalize();

			}

			//if bullet is alive, update it
			if (bulletAlive){
				
				moveBullet();
				//now we test for a collision between bullet and dome's collisionSphere
				bulletRayCollisionPoint = bulletRay.intersectSphere(collisionSphere1);
					
				if (bulletRayCollisionPoint) {
					//compare the distance between collision point and bullet object, vs. where the
					//bullet is now and where the bullet will end up the next frame, and if the first 
					//length is less, we have a collision.  Else, the collision point is too far away still.
					if (bulletRayCollisionPoint.distanceToSquared(bulletSphere.position) < 
						newBulletSpherePos.distanceToSquared(oldBulletSpherePos)){
						
						//the following will freeze the projectile
						//bulletAlive = false;
						
						//place it right where the collision occurred
						bulletSphere.position.copy(bulletRayCollisionPoint);
						
						//the following is optional:
						//get the collisionNormal so we can bounce the bullet off the dome
						collisionNormal.subVectors(dome.position, bulletRayCollisionPoint);
						collisionNormal.normalize();
						
						//the following will send the bullet projectile on its new path
						bulletDirection.reflect(collisionNormal);
						
						//move the bullet out a little on this new path so it doesn't get stuck 
						//in endless bouncing back and forth
						moveBullet();
						
						//save the collision point for debug output
						savedCollisionPoint.copy(bulletRayCollisionPoint);
						
					}// end if (bulletRayCollisionPoint.distanceToSquared
					
				}//end if (bulletRayCollisionPoint)
				
				//now we test for a collision between bullet and whiteSphere's collisionSphere
				bulletRayCollisionPoint = bulletRay.intersectSphere(collisionSphere2);
					
				if (bulletRayCollisionPoint) {
					
					if (bulletRayCollisionPoint.distanceToSquared(bulletSphere.position) < 
						newBulletSpherePos.distanceToSquared(oldBulletSpherePos)){
						
						bulletSphere.position.copy(bulletRayCollisionPoint);
						
						collisionNormal.subVectors(whiteSphere.position, bulletRayCollisionPoint);
						collisionNormal.normalize();
						
						bulletDirection.reflect(collisionNormal);
						
						moveBullet();
						
						savedCollisionPoint.copy(bulletRayCollisionPoint);
						
					}// end if (bulletRayCollisionPoint.distanceToSquared
					
				}//end if (bulletRayCollisionPoint)
				
			}//end if (bulletAlive)

			//move the ship along its normalized axis vector, at the rate of shipSpeed times the framerate
			//because we're in space, the following is always called and the ship will move forever in the player's intended direction
			ship.translateOnAxis(normalizedShipDirection, shipSpeed * frameTime);
			//set camera position from ship position
			camera.position.copy(ship.position);
			
			//test code for rotating sprites
			//crossHairsSprite.material.rotation += 2 * frameTime;
			
			//update the controls
			controls.update(frameTime);
			//render the scene with our camera
			renderer.render(scene, camera);

			//helpful real-time debug text, so we can monitor game variables
			debugText1.innerHTML = "collisionPointX: " + savedCollisionPoint.x.toFixed(1);
			debugText2.innerHTML = "collisionPointY: " + savedCollisionPoint.y.toFixed(1);
			debugText3.innerHTML = "collisionPointZ: " + savedCollisionPoint.z.toFixed(1);
			//debugText4.innerHTML = "savedMousePosY: " + joystick.savedMousePosY;
			

		} //end function animate()

		function shootBullet() {

			//set bullet to alive
			bulletAlive = true;
			//spawn bullet at player's location
			bulletSphere.position.copy(ship.position);
			//reset the bulletDirection vector to unit length of 1 to avoid accumulation
			bulletDirection.set(0, 0, -1);
			//rotate the vector by our camera's rotation quaternion
			bulletDirection.applyQuaternion(camera.quaternion);
			//now the bullet is pointing in the right direction, move it out away from the ship a little,
			//so it doesn't start right inside the ship
			bulletSphere.translateOnAxis(bulletDirection, 15);

		}

		function moveBullet() {
			
			bulletRay.set(bulletSphere.position, bulletDirection);
			//record the current bullet location
			oldBulletSpherePos.copy(bulletSphere.position);
			//move bullet along bulletDirection vector, at the rate of bulletSpeed times the framerate
			bulletSphere.translateOnAxis(bulletDirection, bulletSpeed * frameTime);
			//now that we have moved it, record the new bullet location
			newBulletSpherePos.copy(bulletSphere.position);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();
			
		}
	</script>
</body>

</html>
